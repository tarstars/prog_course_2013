лекция-13

Метод Рунге-Кутта четвёртого порядка
	k1 = dt*f(z_(p), t);            k2 = dt*f(z_(p)+k1/2, t+dt/2);
	k3 = dt*f(z_(p)+k2/2, t+dt/2);  k4 = dt*f(z_(p)+k3, t+dt);
	z_(p+1) = 1/6*(k1+2*k2+2*k3+k4) + z_(p);
	
	проблема: хотим работать с разными функциями
	решения: 1) указатель на ф-ию;
			 2) наследование
			 3) шаблоны
_________________________________________________________________

си-стиль программирование = лаконично, но не очень понятно
while(*(p1++) = *(p2++))

//указатель р2 сдвигается и теперь указывает на второй эл-т массива, но операция * вернёт предыдущее значение, т.е. первый эл-т

с++ ситиль программирования = ... с точностью до наоборот
while(p2) {
	*p1 = *p2;
	++p1;
	++p2
}
__________________________________________________________________

лекция-15

НАСЛЕДОВАНИЕ

Пример:

f(A& transformer) { //ссылка м. указывать на объект класса А и любых производных от него классов
	int x = 1;
	x = transformer.eval(x); //eval относится к производным классам
	cout << x;
}

A1 t1; //class A1 (производный класс) и A связаны отношением наследования
f(t1);
___________

Теория:

class A {
public:
	int eval(int x) {return x+1;}
};

class A1: public A {
public:
	int eval(int x) {return x+2;}
};

Makefile будет выглядеть так:

main: main.o a.o a1.o
	$(CXX) -o $@ $^
main.o: main.cpp a.h a1.h
a.o: a.cpp a.h
a1.o: a1.cpp a1.h

__________________________________________________________________
__________________________________________________________________

Лекция 16.
РЕШЕНИЕ УРАВНЕНИЯ КРИСТОФФЕЛЯ

1)Задача
распространение плоских акустических волн в твёрдом теле
коэф. упругости c_ijkl => скорость волны v ~ sqrt(c/pho)
	Г_ik = c_ijkl*n_i*n_l - тензор кристоффеля
	y = pho*v^2
	(Г - I*y)*q=0 //q - поляризация, I - единичная матрица
	det()=0 => (pho*v^2)_i => q_i
	
симметрия
	cijkl = cjikl = cijlk = cklij
	поэтому
		    (1)  (2)  (3)
		(1)  1    6    5
		(2)  6    2    4   ijkl -> ab
		(3)  5    4    3
		
чтобы перейми в НОВУЮ СИСТЕМУ КООРДИНАТ, нужно ввести матрицу перехода m_ij:
c'_pqrs = c_ijkl * m_pi * m_qi * m_rk * m_sl
m = (x'_x x'_y x'_z
	 y'_x y'_y y'_z
	 y'_x y'_y y'_z)
элементы - проекции новых коорднат на старые
____________________________

2. Решение на С++
	1) vec3 - нормаль
	2) tensor4 - упругие постоянные
	3) mat3 - тензор кристоффеля Г_ik
	4) polynomial - полином для y
	5) solpart - пара скорость-поляризация
	6) util.h util.cpp - объявление и определение внешних функций
_________________________________________________________________

Библиотеки STL
	1) tr1 - умные указатели
	2) boost
			math / ublus - простые операции с матрицами
			
Оператор =
	1) класс auto_ptr => копируется указатель, а прежний зануляется
	2) создаём новый объект с содержанием старого с новым указателем
	3) к объекту привязываем счётчик (кол-во указателей у данного объекта)
		если не иизменяем объект, то копируем указатель, в противном случае создаём новый объект
		
_____________________________________________________________________

В 2011 году появился новый стандарт std с++11
	раньше: g++ main.cpp -o prog               // 2003 год
	теперь: g++ main.cpp -o prog -std = c++11
			1) .pro:  QMAKE_CXXFLAGS += -std=c++11
			2) Makefile: CXXFLACS += -std = c++11
	изменения:
			core: поддержка Lambda-функций, новый синтаксис
			
____________________________________________________________________-

Поиск по шаблону:

Wildcard
	.txt - поиск текстовых файлов
	a* - начальная буква в названии файла

Regular Expression
./prog '.aa' swaa
где .aa - рег.выражение, которое мы пытаемся найти в строке swaa
!!! кавычки обязательны
	 .	- любой символ
	 *	- любое число вхождений (в т.ч. ноль)
	 .*	- здесь может быть всё, что угодно
	 +	- 1 или более вхождений
	 ?	- 0 или 1 вхождение
	 reg1|reg2 - одно из рег.выр.
	 [asd] - совпадает одна из букв
	 [1-6] - 123456
	 [a-z] - алфавит
	 [^a-z] - любой символ кроме
	 \\ - открывающаяся или закрывающаяся скобка
	 ./prog < snowman.pc